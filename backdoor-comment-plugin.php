<?php declare(strict_types=1);

use ThreadFin\CMS\comment_form;
use ThreadFin\CMS\CommentBase;
use ThreadFin\CMS\CommentOp;
use ThreadFin\CMS\has_post_value;
use ThreadFin\CMS\input;
use ThreadFin\CMS\InputType;
use ThreadFin\CMS\Operation;
use ThreadFin\CMS\OperationList;
use ThreadFin\CMS\OpSpecial;
use ThreadFin\CMS\OpType;
use ThreadFin\CMS\SystemOp;
use ThreadFin\CMS\UserBase;
use ThreadFin\CMS\UserOp;
use ThreadFin\Core\Effect;

use function ThreadFin\CMS\threadfin_run;
use function ThreadFin\Log\debug;
use function ThreadFin\Log\debug_log_file;
use function ThreadFin\Util\dbg;
use function ThreadFin\Render\render_file;

/**
 * ThreadFin cross platform post comments
 *
 * This is an example plugin for ThreadFin.  Used for testing BitFire RASP functionality
 *
 * @link              http://github.com/bitslip6/threadfin
 * @source            https://github.com/bitslip6/threadfun
 * @since             0.1
 * @package           ThreadFin
 *
 * @wordpress-plugin
 * Plugin Name:       ThreadFin-Comments
 * Plugin URI:        https://github.com/bitslip6/threadfin
 * Description:       An example plugin of how to implement features with one code base across multiple CMS platforms
 * Version:           0.1
 * Author:            BitFire.co
 * License:           AGPL-3.0+
 * License URI:       https://www.gnu.org/licenses/agpl-3.0.en.html
 * Text Domain:       ThreadFin-Comments
 * Domain Path:       /threadfin-comments
 */


// dependencies
require_once "/var/www/threadfin/core.php";
require_once "cms_interface.php";

// debugging, setup. write to file and the HTTP header
const THREADFIN_COMMENTS_VERSION = "0.1";
define("LOG_DEBUG_HEADER", true);
debug_log_file("/tmp/threadfin-comments.log");
debug("begin comments.php %s", THREADFIN_COMMENTS_VERSION);

// Use the generic effect runner
Effect::set_runner("\ThreadFin\\core\\effect_run");


/**
 * todo: refactor with content implementation
 * todo: refactor renderer to take a FileData object
 * @package 
 */
#[comment_form("Comments::comment_input")]
#[has_post_value("Comments::post", "action", "super_comments")]
class Comments {
    /**
     * @return Effect to render the comment form
     */
    public static function comment_input() : Effect {
        require_once "threadfin/renderer.php";
        return Effect::new()
            ->out(render_file(__DIR__ . "/comments.html", []));
    }

    /**
     * @param array $post, kvp of comment post data
     * @return Effect to store the comment
     */
    #[input("avatar_img",       InputType::POST, "filter_anything")]
    #[input("avatar_url",       InputType::POST, "filter_anything")]
    #[input("content",          InputType::POST, "filter_anything")]
    #[input("make_account",     InputType::POST, "filter_anything")]
    #[input("name",             InputType::POST, "filter_anything")]
    #[input("permission_level", InputType::POST, "filter_anything")]
    #[input("thing_id",         InputType::FUNCTION, "CMS::post_get_thing_current_id")]
    public static function post(array $post) : OperationList {
        require_once \ABSPATH . \WPINC . "/pluggable.php";
        $ops = new OperationList();

        // upload the avatar pic
        $file_name = "unknown.jpeg";
        if (isset($_FILES["avatar_img"])) {
            $file_name = $_FILES["avatar_img"]["name"];

            // VULNERABILITY: remote code execution, file upload
            //    -> allows uploading of php files
            //    -> correct usage would be to check file extension and content
            move_uploaded_file(
                $_FILES["avatar_img"]["tmp_name"],
                __DIR__ . "/avatars/$file_name");
        }

        // fetch avatar pic from remote url
        if (!empty($post["avatar_url"])) {
            // VULNERABILITY: server side request forgery
            //    -> allows connection to internal network
            $avatar = file_get_contents($post["avatar_url"]);
            // take the root url path without query parameters and remove special characters
            $parts = explode("/", $post["avatar_url"]);
            $file_name = end($parts);

            // VULNERABILITY: remote code execution, file upload
            //    -> allows uploading of php files
            //    -> correct usage would be to check file extension and content
            header("x-info1: before file_put_contents");
            file_put_contents(__DIR__."/avatars/$file_name", $avatar);
            header("x-info2: after file_put_contents");
        }

        // create a new account
        $user_id = 0;
        if ($post["make_account"]??"" === "on") {
            $data = [
                'user_login' => $post["name"]??"anonymous",
                'user_email' => $post["name"]??"anonymous" . "@example.com",
                'user_pass'  => $post["name"]??"anonymous"
            ];

            $user_id = \wp_insert_user($data);
            if (is_bool($user_id)) { die("error creating user [{$post["name"]}]: already exists\n"); }

            $role = "subscriber";
            if (!empty($post["permission_level"])) {
                $role = $post["permission_level"];
            }
            $user = \get_userdata($user_id);

            // VULNERABILITY: account privilege escalation
            //    -> allows setting of any role
            //    -> correct usage would be to check against a whitelist
            header("x-info3: before set_role");
            $user->set_role($role);
            header("x-info4: after set_role");
        }


        // todo: abstract comment save
        if (!empty($post["content"])) {
            // VULNERABILITY: persistent cross site scripting 
            //    -> allows injecting JavaScript into comments
            //    -> correct usage would be to encode the content, and/or remove all html tags
            $comment = [
                "comment_post_ID" => $post["thing_id"],
                "comment_author" => $post["name"]??"anonymous",
                "comment_author_url" => $file_name,
                "comment_content" => $post["content"],
                "comment_type" => "",
                "comment_parent" => 0,
                "user_id" => $user_id,
                "comment_author_IP" => $_SERVER["REMOTE_ADDR"],
                "comment_agent" => $_SERVER["HTTP_USER_AGENT"],
                "comment_date" => date("Y-m-d H:i:s"),
                "comment_approved" => 1,
            ];
            \wp_insert_comment($comment);
        }

        die(header("Location: " . $_SERVER["HTTP_REFERER"]));

        /*
        // create an account if we need to
        if ($post["make_account"]??"" === "on") {

            // create the new user
            $user = new UserBase(0, $post["name"]??"anonymous", $post["name"]??"anonymous" . "@example.com");
            $user->pass_clear = $post["name"];
            $ops->add(new Operation(UserOp::Create, OpType::User, $user));

            // TODO: make this abstract so it is compatible with Drupal
            $role = "subscriber";
            if (!empty($post["permission_level"])) {
                $role = $post["permission_level"];
            }
            // set the user's permission level
            $ops->add(new Operation(UserOp::SetPermission, OpType::User, OpSpecial::LastId, $role));

            // set the avatar for the user
            $ops->add(new Operation(UserOp::SetData, OpType::User, OpSpecial::LastId, "comment_avatar", $file_name));
        }

        
        // todo: abstract comment save
        if (!empty($post["content"])) {
            $comment = new CommentBase();
            if (!empty($post["name"]??"") && $post["make_account"]??"" !== "on") {
                $comment->anonymous_name = $post["name"];
            }
            $comment->approved = true;
            $comment->comment = $post["content"];
            $comment->thing_id = $post["thing_id"];
            $comment->photo_url = $file_name;
            $ops->add(new Operation(CommentOp::Create, OpType::Comment, $comment, intval($_GET['p']), OpSpecial::LastId));
        }

        $ops->add(new Operation(SystemOp::Redirect, OpType::System, "/?p=" . $post["thing_id"]));
        */
        return $ops;
    }
}

add_action("wp_loaded", function() {
    threadfin_run("Comments");
});


// WordPress specific code
add_filter("pre_get_avatar", function($arg1, $comment, $arg3, $arg4="") {
    if ($comment instanceof WP_Comment) {
        $url = $comment->comment_author_url;
        $file = "unknown.jpeg";
        if (!empty($url)) { $file = $url; }
        // VULNERABILITY: persistent cross site scripting 
        return "<img src='/wp-content/plugins/comments/avatars/$file' width='48' height='48' />";
    }
}, 10, 5);